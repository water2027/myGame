<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            display: fixed;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <canvas id="game"></canvas>
    <script>
        let ws = null
        document.addEventListener('DOMContentLoaded', () => {
            ws = new WebSocket('ws://localhost:3000')
            ws.onopen = () => {
                console.log('connected')
            }
            ws.onmessage = (e) => {
                console.log(e.data)
                solve(JSON.parse(e.data))
            }
        })
        const solve = (e) => {
            if (e.message === "move") {
                drawChess(e.x, e.y, e.user)
            }
            else if (e.message === "win") {
                chess.win = true;
                alert(e.user + 'win')
            }
            else if (e.message === "start") {
                user = e.user
                chess.ok = true
            }
        }
        var canvas = document.getElementById('game');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        class chessBorad {
            constructor(len) {
                //len为井字棋格子边长
                this.len = len * devicePixelRatio;
                this.ctx = canvas.getContext('2d');
                this.chessArr = [['', '', ''], ['', '', ''], ['', '', '']];
                this.win = false;
                this.ok = false;
            }
            init() {
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - this.len * 3 / 2, centerY - this.len / 2);
                this.ctx.lineTo(centerX + this.len * 3 / 2, centerY - this.len / 2);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - this.len * 3 / 2, centerY + this.len / 2);
                this.ctx.lineTo(centerX + this.len * 3 / 2, centerY + this.len / 2);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - this.len / 2, centerY - this.len * 3 / 2);
                this.ctx.lineTo(centerX - this.len / 2, centerY + this.len * 3 / 2);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(centerX + this.len / 2, centerY - this.len * 3 / 2);
                this.ctx.lineTo(centerX + this.len / 2, centerY + this.len * 3 / 2);
                this.ctx.stroke();
            }
            drawChess(x, y, user) {
                this.ctx.beginPath();
                if (user === "X") {
                    this.ctx.moveTo(centerX + this.len * (x - 1.5), centerY + this.len * (y - 1.5));
                    this.ctx.lineTo(centerX + this.len * (x - 0.5), centerY + this.len * (y - 0.5));
                    this.ctx.moveTo(centerX + this.len * (x - 0.5), centerY + this.len * (y - 1.5));
                    this.ctx.lineTo(centerX + this.len * (x - 1.5), centerY + this.len * (y - 0.5));
                    this.ctx.stroke();
                }
                else {
                    this.ctx.arc(centerX + this.len * (x - 1), centerY + this.len * (y - 1), this.len / 2, 0, 2 * Math.PI);
                    this.ctx.stroke();
                }
                this.chessArr[x][y] = user;
                chess.ok = false;
            }
            isInside(x, y) {
                if (x < centerX - this.len * 3 / 2 || x > centerX + this.len * 3 / 2 || y < centerY - this.len * 3 / 2 || y > centerY + this.len * 3 / 2) {
                    return {
                        x: null,
                        y: null
                    }
                }
                return {
                    x: Math.floor((x - centerX + this.len / 2) / this.len) + 1,
                    y: Math.floor((y - centerY + this.len / 2) / this.len) + 1
                }
            }
            isOk(x, y) {
                return this.chessArr[x][y] === '' && !this.win && this.ok
            }
            isWin(x, y) {
                try {
                    if (this.chessArr[x][y] === this.chessArr[x][((y + 1) % 3 + 3) % 3] && this.chessArr[x][y] === this.chessArr[x][((y + 2) % 3 + 3) % 3]) {
                        this.win = true;
                        window.onload = () => {
                            alert(this.chessArr[x][y] + 'win');
                        }
                        return
                    }
                    if (this.chessArr[x][y] === this.chessArr[((x + 1) % 3 + 3) % 3][y] && this.chessArr[x][y] === this.chessArr[((x + 2) % 3 + 3) % 3][y]) {
                        this.win = true;
                        window.onload = () => {
                            alert(this.chessArr[x][y] + 'win');
                        }
                        return
                    }
                    if (x !== y && x !== 2 - y) {
                        return
                    }
                    if (this.chessArr[x][y] === this.chessArr[((x + 1) % 3 + 3) % 3][((y + 1) % 3 + 3) % 3] && this.chessArr[x][y] === this.chessArr[((x + 2) % 3 + 3) % 3][((y + 2) % 3 + 3) % 3]) {
                        this.win = true;
                        window.onload = () => {
                            alert(this.chessArr[x][y] + 'win');
                        }
                        return
                    }
                    if (this.chessArr[x][y] === this.chessArr[((x + 1) % 3 + 3) % 3][((y - 1) % 3 + 3) % 3] && this.chessArr[x][y] === this.chessArr[((x + 2) % 3 + 3) % 3][((y - 2) % 3 + 3) % 3]) {
                        this.win = true;
                        window.onload = () => {
                            alert(this.chessArr[x][y] + 'win');
                        }
                        return
                    }
                } catch (e) {
                    console.log(e);
                    return
                }
            }
        }
        var chess = new chessBorad(100);
        chess.init();
        let user = ''
        canvas.onclick = function (e) {
            const { x, y } = chess.isInside(e.clientX, e.clientY);
            if (x === null) {
                return;
            }
            if (chess.isOk(x, y)) {
                drawChess(x, y, user);
                chess.isWin(x, y);
                ws.send(JSON.stringify({
                    message: "move",
                    x: x,
                    y: y,
                    user: user
                }))
                if (chess.win) {
                    ws.send(JSON.stringify({
                        message: "win",
                        user: user
                    }))
                }
            }
        }

    </script>
</body>

</html>